F2XM1—Compute 2x–1

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 
D9 F0 
F2XM1 
Valid Valid 
Replace ST(0) with (2ST(0) – 1).

Description
Computes the exponential value of 2 to the power of the source operand minus 1. The source operand is located in
register ST(0) and the result is also stored in ST(0). The value of the source operand must lie in the range –1.0 to
+1.0. If the source value is outside this range, the result is undefined.
The following table shows the results obtained when computing the exponential value of various classes of
numbers, assuming that neither overflow nor underflow occurs.
Table 3-26. Results Obtained from F2XM1
Values other than 2 can be exponentiated using the following formula:
xy ← 2(y ∗ log2x)
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

Operation
ST(0) ← (2ST(0) − 1);

FPU Flags Affected
C1
Set to 0 if stack underflow occurred.
Set if result was rounded up; cleared otherwise.
C0, C2, C3
Undefined.
---------------------------------------------------------------------

FABS—Absolute Value

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

D9 E1 
FABS 
Valid Valid 
Replace ST with its absolute value.

Description
Clears the sign bit of ST(0) to create the absolute value of the operand. The following table shows the results
obtained when creating the absolute value of various classes of numbers.
Table 3-27. Results Obtained from FABS

Operation
ST(0) ← |ST(0)|;

FPU Flags Affected
C1 Set to 0.
C0, C2, C3 Undefined.
---------------------------------------------------------------------

FADD/FADDP/FIADD—Add
Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

D8 /0 
FADD m32fp 
Valid Valid 
Add m32fp to ST(0) and store result in ST(0).

DC /0 
FADD m64fp 
Valid Valid 
Add m64fp to ST(0) and store result in ST(0).

D8 C0+i 
FADD ST(0), ST(i) 
Valid Valid 
Add ST(0) to ST(i) and store result in ST(0).

DC C0+i 
FADD ST(i), ST(0) 
Valid Valid 
Add ST(i) to ST(0) and store result in ST(i).

DE C0+i 
FADDP ST(i), ST(0) 
Valid Valid 
Add ST(0) to ST(i), store result in ST(i), and pop the
 register stack.

DE C1 
FADDP 
Valid Valid 
Add ST(0) to ST(1), store result in ST(1), and pop the
 register stack.

DA /0 
FIADD m32int 
Valid Valid 
Add m32int to ST(0) and store result in ST(0).

DE /0 
FIADD m16int 
Valid Valid 
Add m16int to ST(0) and store result in ST(0).

Description
Adds the destination and source operands and stores the sum in the destination location. The destination operand
is always an FPU register; the source operand can be a register or a memory location. Source operands in memory
can be in single-precision or double-precision floating-point format or in word or doubleword integer format.
The no-operand version of the instruction adds the contents of the ST(0) register to the ST(1) register. The one-
operand version adds the contents of a memory location (either a floating-point or an integer value) to the contents
of the ST(0) register. The two-operand version, adds the contents of the ST(0) register to the ST(i) register or vice
versa. The value in ST(0) can be doubled by coding:
FADD ST(0), ST(0);
The FADDP instructions perform the additional operation of popping the FPU register stack after storing the result.
To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP)
by 1. (The no-operand version of the floating-point add instructions always results in the register stack being
popped. In some assemblers, the mnemonic for this instruction is FADD rather than FADDP.)
The FIADD instructions convert an integer source operand to double extended-precision floating-point format
before performing the addition.
The table on the following page shows the results obtained when adding various classes of numbers, assuming that
neither overflow nor underflow occurs.
When the sum of two operands with opposite signs is 0, the result is +0, except for the round toward −∞ mode, in
which case the result is −0. When the source operand is an integer 0, it is treated as a +0.
When both operand are infinities of the same sign, the result is ∞ of the expected sign. If both operands are infini-
ties of opposite signs, an invalid-operation exception is generated. See Table 3-28.
Table 3-28. FADD/FADDP/FIADD Results

Operation
IF Instruction = FIADD
THEN
DEST ← DEST + ConvertToDoubleExtendedPrecisionFP(SRC);
ELSE (* Source operand is floating-point value *)
DEST ← DEST + SRC;
FI;
IF Instruction = FADDP
THEN
PopRegisterStack;
FI;

FPU Flags Affected
C1
Set to 0 if stack underflow occurred.
Set if result was rounded up; cleared otherwise.
C0, C2, C3
Undefined.
---------------------------------------------------------------------

FBLD—Load Binary Coded Decimal

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

DF /4 
FBLD m80dec 
Valid Valid 
Convert BCD value to floating-point and push onto the
 FPU stack.

Description
Converts the BCD source operand into double extended-precision floating-point format and pushes the value onto
the FPU stack. The source operand is loaded without rounding errors. The sign of the source operand is preserved,
including that of −0.
The packed BCD digits are assumed to be in the range 0 through 9; the instruction does not check for invalid digits
(AH through FH). Attempting to load an invalid encoding produces an undefined result.
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

Operation
TOP ← TOP − 1;
ST(0) ← ConvertToDoubleExtendedPrecisionFP(SRC);

FPU Flags Affected
C1 Set to 1 if stack overflow occurred; otherwise, set to 0.
C0, C2, C3 Undefined.
---------------------------------------------------------------------

FBSTP—Store BCD Integer and Pop

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

DF /6 
FBSTP m80bcd 
Valid Valid 
Store ST(0) in m80bcd and pop ST(0).

Description
Converts the value in the ST(0) register to an 18-digit packed BCD integer, stores the result in the destination
operand, and pops the register stack. If the source value is a non-integral value, it is rounded to an integer value,
according to rounding mode specified by the RC field of the FPU control word. To pop the register stack, the
processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
The destination operand specifies the address where the first byte destination value is to be stored. The BCD value
(including its sign bit) requires 10 bytes of space in memory.
The following table shows the results obtained when storing various classes of numbers in packed BCD format.
Table 3-29. FBSTP Results
NOTES:
F Means finite floating-point value.
D Means packed-BCD number.
* Indicates floating-point invalid-operation (#IA) exception.
** ±0 or ±1, depending on the rounding mode.
If the converted value is too large for the destination format, or if the source operand is an ∞, SNaN, QNAN, or is in
an unsupported format, an invalid-arithmetic-operand condition is signaled. If the invalid-operation exception is
not masked, an invalid-arithmetic-operand exception (#IA) is generated and no value is stored in the destination
operand. If the invalid-operation exception is masked, the packed BCD indefinite value is stored in memory.
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

Operation
DEST ← BCD(ST(0));
PopRegisterStack;
FPU Flags Affected
C1
Set to 0 if stack underflow occurred.
Set if result was rounded up; cleared otherwise.
C0, C2, C3
Undefined.
---------------------------------------------------------------------
