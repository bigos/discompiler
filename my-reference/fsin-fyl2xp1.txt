387
FSIN—Sine

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

D9 FE 
FSIN 
Valid Valid 
Replace ST(0) with its sine.

Description
Computes the sine of the source operand in register ST(0) and stores the result in ST(0). The source operand must
be given in radians and must be within the range −263 to +263. The following table shows the results obtained when
taking the sine of various classes of numbers, assuming that underflow does not occur.
Table 3-45. FSIN Results
SRC (ST(0))
DEST (ST(0))
−∞ *
−F − 1 to + 1
−0 −0
+0 +0
+F − 1 to +1
+∞ *
NaN NaN
NOTES:
F Means finite floating-point value.
* Indicates floating-point invalid-arithmetic-operand (#IA) exception.
If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in
register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of
range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range −
263 to +263 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2π or by
using the FPREM instruction with a divisor of 2π. See the section titled “Pi” in Chapter 8 of the Intel® 64 and IA-32
Architectures Software Developer’s Manual, Volume 1, for a discussion of the proper value to use for π in
performing such reductions.
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

Operation
IF -263 < ST(0) < 263
THEN
C2 ← 0;
ST(0) ← sin(ST(0));
ELSE (* Source operand out of range *)
C2 ← 1;
FI;

FPU Flags Affected
C1
Set to 0 if stack underflow occurred.
Set if result was rounded up; cleared otherwise.
C2 Set to 1 if outside range (−263 < source operand < +263); otherwise, set to 0.
C0, C3 Undefined.
---------------------------------------------------------------------

389
FSINCOS—Sine and Cosine

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

D9 FB 
FSINCOS 
Valid Valid 
Compute the sine and cosine of ST(0); replace ST(0) with the
 sine, and push the cosine onto the register stack.

Description
Computes both the sine and the cosine of the source operand in register ST(0), stores the sine in ST(0), and
pushes the cosine onto the top of the FPU register stack. (This instruction is faster than executing the FSIN and
FCOS instructions in succession.)
The source operand must be given in radians and must be within the range −263 to +263. The following table shows
the results obtained when taking the sine and cosine of various classes of numbers, assuming that underflow does
not occur.
Table 3-46. FSINCOS Results
SRC
ST(0)
DEST
ST(1) Cosine
ST(0) Sine
−∞ * *
−F − 1 to + 1 − 1 to + 1
−0 +1 −0
+0 +1 +0
+F − 1 to + 1 − 1 to + 1
+∞ * *
NaN NaN NaN
NOTES:
F Means finite floating-point value.
* Indicates floating-point invalid-arithmetic-operand (#IA) exception.
If the source operand is outside the acceptable range, the C2 flag in the FPU status word is set, and the value in
register ST(0) remains unchanged. The instruction does not raise an exception when the source operand is out of
range. It is up to the program to check the C2 flag for out-of-range conditions. Source values outside the range −
263 to +263 can be reduced to the range of the instruction by subtracting an appropriate integer multiple of 2π or by
using the FPREM instruction with a divisor of 2π. See the section titled “Pi” in Chapter 8 of the Intel® 64 and IA-32
Architectures Software Developer’s Manual, Volume 1, for a discussion of the proper value to use for π in
performing such reductions.
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

Operation
IF ST(0) < 263
THEN
C2 ← 0;
TEMP ← cosine(ST(0));
ST(0) ← sine(ST(0));
TOP ← TOP − 1;
ST(0) ← TEMP;
ELSE (* Source operand out of range *)
C2 ← 1;
FI;

FPU Flags Affected
C1
Set to 0 if stack underflow occurred; set to 1 of stack overflow occurs.
Set if result was rounded up; cleared otherwise.
C2 Set to 1 if outside range (−263 < source operand < +263); otherwise, set to 0.
C0, C3 Undefined.
---------------------------------------------------------------------

391
FSQRT—Square Root

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

D9 FA 
FSQRT
Valid Valid 
Computes square root of ST(0) and stores the result in ST(0).

Description
Computes the square root of the source value in the ST(0) register and stores the result in ST(0).
The following table shows the results obtained when taking the square root of various classes of numbers,
assuming that neither overflow nor underflow occurs.
Table 3-47. FSQRT Results
SRC (ST(0)) DEST (ST(0))
−∞ *
−F *
−0 −0
+0 +0
+F +F
+∞ +∞
NaN NaN
NOTES:
F Means finite floating-point value.
* Indicates floating-point invalid-arithmetic-operand (#IA) exception.
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

Operation
ST(0) ← SquareRoot(ST(0));

FPU Flags Affected
C1
Set to 0 if stack underflow occurred.
Set if result was rounded up; cleared otherwise.
C0, C2, C3
Undefined.
---------------------------------------------------------------------

393
FST/FSTP—Store Floating Point Value

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

D9 /2 
FST m32fp 
Valid Valid 
Copy ST(0) to m32fp.

DD /2 
FST m64fp 
Valid Valid 
Copy ST(0) to m64fp.

DD D0+i 
FST ST(i) 
Valid Valid 
Copy ST(0) to ST(i).

D9 /3 
FSTP m32fp 
Valid Valid 
Copy ST(0) to m32fp and pop register stack.

DD /3 
FSTP m64fp 
Valid Valid 
Copy ST(0) to m64fp and pop register stack.

DB /7 
FSTP m80fp 
Valid Valid 
Copy ST(0) to m80fp and pop register stack.

DD D8+i 
FSTP ST(i) 
Valid Valid 
Copy ST(0) to ST(i) and pop register stack.

Description
The FST instruction copies the value in the ST(0) register to the destination operand, which can be a memory loca-
tion or another register in the FPU register stack. When storing the value in memory, the value is converted to
single-precision or double-precision floating-point format.
The FSTP instruction performs the same operation as the FST instruction and then pops the register stack. To pop
the register stack, the processor marks the ST(0) register as empty and increments the stack pointer (TOP) by 1.
The FSTP instruction can also store values in memory in double extended-precision floating-point format.
If the destination operand is a memory location, the operand specifies the address where the first byte of the desti-
nation value is to be stored. If the destination operand is a register, the operand specifies a register in the register
stack relative to the top of the stack.
If the destination size is single-precision or double-precision, the significand of the value being stored is rounded
to the width of the destination (according to the rounding mode specified by the RC field of the FPU control word),
and the exponent is converted to the width and bias of the destination format. If the value being stored is too large
for the destination format, a numeric overflow exception (#O) is generated and, if the exception is unmasked, no
value is stored in the destination operand. If the value being stored is a denormal value, the denormal exception
(#D) is not generated. This condition is simply signaled as a numeric underflow exception (#U) condition.
If the value being stored is ±0, ±∞, or a NaN, the least-significant bits of the significand and the exponent are trun-
cated to fit the destination format. This operation preserves the value’s identity as a 0, ∞, or NaN.
If the destination operand is a non-empty register, the invalid-operation exception is not generated.
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

Operation
DEST ← ST(0);
IF Instruction = FSTP
THEN
PopRegisterStack;
FI;

FPU Flags Affected
C1
Set to 0 if stack underflow occurred.
Indicates rounding direction of if the floating-point inexact exception (#P) is generated: 0 ←
not roundup; 1 ← roundup.
C0, C2, C3
Undefined.
---------------------------------------------------------------------

395
FSTCW/FNSTCW—Store x87 FPU Control Word

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

9B D9 /7 
FSTCW m2byte 
Valid Valid 
Store FPU control word to m2byte after checking for
 pending unmasked floating-point exceptions.

D9 /7 
FNSTCW m2byte 
Valid Valid 
Store FPU control word to m2byte without checking for
 pending unmasked floating-point exceptions.

NOTES:
* See IA-32 Architecture Compatibility section below.

Description
Stores the current value of the FPU control word at the specified destination in memory. The 

FSTCW instruction
checks for and handles pending unmasked floating-point exceptions before storing the control word; the FNSTCW
instruction does not.
The assembler issues two instructions for the FSTCW instruction (an FWAIT instruction followed by an FNSTCW
instruction), and the processor executes each of these instructions in separately. If an exception is generated for
either of these instructions, the save EIP points to the instruction that caused the exception.
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

IA-32 Architecture Compatibility
When operating a Pentium or Intel486 processor in MS-DOS compatibility mode, it is possible (under unusual
circumstances) for an FNSTCW instruction to be interrupted prior to being executed to handle a pending FPU
exception. See the section titled “No-Wait FPU Instructions Can Get FPU Interrupt in Window” in Appendix D of the
Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a description of these circum-
stances. An FNSTCW instruction cannot be interrupted in this way on a Pentium 4, Intel Xeon, or P6 family
processor.

Operation
DEST ← FPUControlWord;

FPU Flags Affected
The C0, C1, C2, and C3 flags are undefined.
---------------------------------------------------------------------

397
FSTENV/FNSTENV—Store x87 FPU Environment

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

9B D9 /6 
FSTENV m14/28byte 
Valid Valid 
Store FPU environment to m14byte or m28byte
 after checking for pending unmasked floating-point
 exceptions. Then mask all floating-point exceptions.

D9 /6 
FNSTENV m14/28byte 
Valid Valid 
Store FPU environment to m14byte or m28byte
 without checking for pending unmasked floating-
 point exceptions. Then mask all floating-
 point exceptions.

NOTES:
* See IA-32 Architecture Compatibility section below.

Description
Saves the current FPU operating environment at the memory location specified with the destination operand, and
then masks all floating-point exceptions. The FPU operating environment consists of the FPU control word, status
word, tag word, instruction pointer, data pointer, and last opcode. Figures 8-9 through 8-12 in the Intel® 64 and
IA-32 Architectures Software Developer’s Manual, Volume 1, show the layout in memory of the stored environ-
ment, depending on the operating mode of the processor (protected or real) and the current operand-size attribute
(16-bit or 32-bit). In virtual-8086 mode, the real mode layouts are used.
The 

FSTENV instruction checks for and handles any pending unmasked floating-point exceptions before storing
the FPU environment; the FNSTENV instruction does not. The saved image reflects the state of the FPU after all
floating-point instructions preceding the FSTENV/FNSTENV instruction in the instruction stream have been
executed.
These instructions are often used by exception handlers because they provide access to the FPU instruction and
data pointers. The environment is typically saved in the stack. Masking all exceptions after saving the environment
prevents floating-point exceptions from interrupting the exception handler.
The assembler issues two instructions for the FSTENV instruction (an FWAIT instruction followed by an FNSTENV
instruction), and the processor executes each of these instructions separately. If an exception is generated for
either of these instructions, the save EIP points to the instruction that caused the exception.
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

IA-32 Architecture Compatibility
When operating a Pentium or Intel486 processor in MS-DOS compatibility mode, it is possible (under unusual
circumstances) for an FNSTENV instruction to be interrupted prior to being executed to handle a pending FPU
exception. See the section titled “No-Wait FPU Instructions Can Get FPU Interrupt in Window” in Appendix D of the
Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a description of these circum-
stances. An FNSTENV instruction cannot be interrupted in this way on a Pentium 4, Intel Xeon, or P6 family
processor.

Operation
DEST[FPUControlWord] ← FPUControlWord;
DEST[FPUStatusWord] ← FPUStatusWord;
DEST[FPUTagWord] ← FPUTagWord;
DEST[FPUDataPointer] ← FPUDataPointer;
DEST[FPUInstructionPointer] ← FPUInstructionPointer;
DEST[FPULastInstructionOpcode] ← FPULastInstructionOpcode;

FPU Flags Affected
The C0, C1, C2, and C3 are undefined.
---------------------------------------------------------------------

399
FSTSW/FNSTSW—Store x87 FPU Status Word

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

9B DD /7 
FSTSW m2byte 
Valid Valid 
Store FPU status word at m2byte after checking
 for pending unmasked floating-point exceptions.

9B DF E0 
FSTSW AX 
Valid Valid 
Store FPU status word in AX register after
 checking for pending unmasked floating-point
 exceptions.

DD /7 
FNSTSW m2byte 
Valid Valid 
Store FPU status word at m2byte without
 checking for pending unmasked floating-point
 exceptions.

DF E0 
FNSTSW AX 
Valid Valid 
Store FPU status word in AX register without
 checking for pending unmasked floating-point
 exceptions.

NOTES:
* See IA-32 Architecture Compatibility section below.

Description
Stores the current value of the x87 FPU status word in the destination location. The destination operand can be
either a two-byte memory location or the AX register. The FSTSW instruction checks for and handles pending
unmasked floating-point exceptions before storing the status word; the FNSTSW instruction does not.
The FNSTSW AX form of the instruction is used primarily in conditional branching (for instance, after an FPU
comparison instruction or an FPREM, FPREM1, or FXAM instruction), where the direction of the branch depends on
the state of the FPU condition code flags. (See the section titled “Branching and Conditional Moves on FPU Condi-
tion Codes” in Chapter 8 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1.) This
instruction can also be used to invoke exception handlers (by examining the exception flags) in environments that
do not use interrupts. When the FNSTSW AX instruction is executed, the AX register is updated before the
processor executes any further instructions. The status stored in the AX register is thus guaranteed to be from the
completion of the prior FPU instruction.
The assembler issues two instructions for the FSTSW instruction (an FWAIT instruction followed by an FNSTSW
instruction), and the processor executes each of these instructions separately. If an exception is generated for
either of these instructions, the save EIP points to the instruction that caused the exception.
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

IA-32 Architecture Compatibility
When operating a Pentium or Intel486 processor in MS-DOS compatibility mode, it is possible (under unusual
circumstances) for an FNSTSW instruction to be interrupted prior to being executed to handle a pending FPU
exception. See the section titled “No-Wait FPU Instructions Can Get FPU Interrupt in Window” in Appendix D of the
Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for a description of these circum-
stances. An FNSTSW instruction cannot be interrupted in this way on a Pentium 4, Intel Xeon, or P6 family
processor.

Operation
DEST ← FPUStatusWord;

FPU Flags Affected
The C0, C1, C2, and C3 are undefined.
---------------------------------------------------------------------

401
FSUB/FSUBP/FISUB—Subtract

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

D8 /4 
FSUB m32fp 
Valid Valid 
Subtract m32fp from ST(0) and store result in ST(0).

DC /4 
FSUB m64fp 
Valid Valid 
Subtract m64fp from ST(0) and store result in ST(0).

D8 E0+i 
FSUB ST(0), ST(i) 
Valid Valid 
Subtract ST(i) from ST(0) and store result in ST(0).

DC E8+i
FSUB ST(i), ST(0) 
Valid Valid 
Subtract ST(0) from ST(i) and store result in ST(i).

DE E8+i 
FSUBP ST(i), ST(0) 
Valid Valid 
Subtract ST(0) from ST(i), store result in ST(i), and
 pop register stack.

DE E9 
FSUBP 
Valid Valid 
Subtract ST(0) from ST(1), store result in ST(1), and
 pop register stack.

DA /4 
FISUB m32int 
Valid Valid 
Subtract m32int from ST(0) and store result in ST(0).

DE /4 
FISUB m16int 
Valid Valid 
Subtract m16int from ST(0) and store result in ST(0).

Description
Subtracts the source operand from the destination operand and stores the difference in the destination location.
The destination operand is always an FPU data register; the source operand can be a register or a memory location.
Source operands in memory can be in single-precision or double-precision floating-point format or in word or
doubleword integer format.
The no-operand version of the instruction subtracts the contents of the ST(0) register from the ST(1) register and
stores the result in ST(1). The one-operand version subtracts the contents of a memory location (either a floating-
point or an integer value) from the contents of the ST(0) register and stores the result in ST(0). The two-operand
version, subtracts the contents of the ST(0) register from the ST(i) register or vice versa.
The FSUBP instructions perform the additional operation of popping the FPU register stack following the subtrac-
tion. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer
(TOP) by 1. The no-operand version of the floating-point subtract instructions always results in the register stack
being popped. In some assemblers, the mnemonic for this instruction is FSUB rather than FSUBP.
The FISUB instructions convert an integer source operand to double extended-precision floating-point format
before performing the subtraction.
Table 3-48 shows the results obtained when subtracting various classes of numbers from one another, assuming
that neither overflow nor underflow occurs. Here, the SRC value is subtracted from the DEST value (DEST − SRC =
result).
When the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode,
in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the
source operand is an integer 0, it is treated as a +0.
When one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalid-
operation exception is generated.

Operation
IF Instruction = FISUB
THEN
DEST ← DEST − ConvertToDoubleExtendedPrecisionFP(SRC);
ELSE (* Source operand is floating-point value *)
DEST ← DEST − SRC;
FI;
IF Instruction = FSUBP
THEN
PopRegisterStack;
FI;

FPU Flags Affected
C1
Set to 0 if stack underflow occurred.
Set if result was rounded up; cleared otherwise.
C0, C2, C3
Undefined.
---------------------------------------------------------------------

404
FSUBR/FSUBRP/FISUBR—Reverse Subtract

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

D8 /5 
FSUBR m32fp 
Valid Valid 
Subtract ST(0) from m32fp and store result in ST(0).

DC /5 
FSUBR m64fp 
Valid Valid 
Subtract ST(0) from m64fp and store result in ST(0).

D8 E8+i 
FSUBR ST(0), ST(i) 
Valid Valid 
Subtract ST(0) from ST(i) and store result in ST(0).

DC E0+i 
FSUBR ST(i), ST(0) 
Valid Valid 
Subtract ST(i) from ST(0) and store result in ST(i).

DE E0+i 
FSUBRP ST(i), ST(0) 
Valid Valid 
Subtract ST(i) from ST(0), store result in ST(i), and
 pop register stack.

DE E1 
FSUBRP 
Valid Valid 
Subtract ST(1) from ST(0), store result in ST(1), and
 pop register stack.

DA /5 
FISUBR m32int 
Valid Valid 
Subtract ST(0) from m32int and store result in ST(0).

DE /5 
FISUBR m16int 
Valid Valid 
Subtract ST(0) from m16int and store result in ST(0).

Description
Subtracts the destination operand from the source operand and stores the difference in the destination location.
The destination operand is always an FPU register; the source operand can be a register or a memory location.
Source operands in memory can be in single-precision or double-precision floating-point format or in word or
doubleword integer format.
These instructions perform the reverse operations of the FSUB, FSUBP, and FISUB instructions. They are provided
to support more efficient coding.
The no-operand version of the instruction subtracts the contents of the ST(1) register from the ST(0) register and
stores the result in ST(1). The one-operand version subtracts the contents of the ST(0) register from the contents
of a memory location (either a floating-point or an integer value) and stores the result in ST(0). The two-operand
version, subtracts the contents of the ST(i) register from the ST(0) register or vice versa.
The FSUBRP instructions perform the additional operation of popping the FPU register stack following the subtrac-
tion. To pop the register stack, the processor marks the ST(0) register as empty and increments the stack pointer
(TOP) by 1. The no-operand version of the floating-point reverse subtract instructions always results in the register
stack being popped. In some assemblers, the mnemonic for this instruction is FSUBR rather than FSUBRP.
The FISUBR instructions convert an integer source operand to double extended-precision floating-point format
before performing the subtraction.
The following table shows the results obtained when subtracting various classes of numbers from one another,
assuming that neither overflow nor underflow occurs. Here, the DEST value is subtracted from the SRC value (SRC
− DEST = result).
When the difference between two operands of like sign is 0, the result is +0, except for the round toward −∞ mode,
in which case the result is −0. This instruction also guarantees that +0 − (−0) = +0, and that −0 − (+0) = −0. When the
source operand is an integer 0, it is treated as a +0.
When one operand is ∞, the result is ∞ of the expected sign. If both operands are ∞ of the same sign, an invalid-
operation exception is generated.
Table 3-49. FSUBR/FSUBRP/FISUBR Results
SRC
−∞
−F or −I
−0
+0 +F or +I +∞ NaN
−∞ 
DEST
* +∞ +∞ +∞ +∞ +∞ NaN
−F −∞ ±F or ±0 −DEST −DEST +F +∞ NaN
−0 −∞ SRC ±0 +0 SRC +∞ NaN
+0 −∞ SRC −0 ±0 SRC +∞ NaN
+F −∞ −F −DEST −DEST ±F or ±0 +∞ NaN
+∞ −∞ −∞ −∞ −∞ −∞ * NaN
NaN NaN NaN NaN NaN NaN NaN NaN
NOTES:
F Means finite floating-point value.
I Means integer.
* Indicates floating-point invalid-arithmetic-operand (#IA) exception.
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

Operation
IF Instruction = FISUBR
THEN
DEST ← ConvertToDoubleExtendedPrecisionFP(SRC) − DEST;
ELSE (* Source operand is floating-point value *)
DEST ← SRC − DEST; FI;
IF Instruction = FSUBRP
THEN
PopRegisterStack; FI;

FPU Flags Affected
C1
Set to 0 if stack underflow occurred.
Set if result was rounded up; cleared otherwise.
C0, C2, C3
Undefined.
---------------------------------------------------------------------

407
FTST—TEST

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

D9 E4 
FTST 
Valid Valid 
Compare ST(0) with 0.0.

Description
Compares the value in the ST(0) register with 0.0 and sets the condition code flags C0, C2, and C3 in the FPU
status word according to the results (see table below).
Table 3-50. FTST Results
Condition C3 C2 C0
ST(0) > 0.0 0 0 0
ST(0) < 0.0 0 0 1
ST(0) = 0.0 1 0 0
Unordered 1 1 1
This instruction performs an “unordered comparison.” An unordered comparison also checks the class of the
numbers being compared (see “FXAM—Examine ModR/M” in this chapter). If the value in register ST(0) is a NaN or
is in an undefined format, the condition flags are set to “unordered” and the invalid operation exception is gener-
ated.
The sign of zero is ignored, so that (– 0.0 ← +0.0).
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

Operation
CASE (relation of operands) OF
Not comparable: C3, C2, C0 ← 111;
ST(0) > 0.0:
C3, C2, C0 ← 000;
ST(0) < 0.0:
C3, C2, C0 ← 001;
ST(0) = 0.0:
C3, C2, C0 ← 100;
ESAC;

FPU Flags Affected
C1 Set to 0.
C0, C2, C3 See Table 3-50.
---------------------------------------------------------------------

409
FUCOM/FUCOMP/FUCOMPP—Unordered Compare Floating Point Values

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

DD E0+i 
FUCOM ST(i) 
Valid Valid 
Compare ST(0) with ST(i).

DD E1 
FUCOM 
Valid Valid 
Compare ST(0) with ST(1).

DD E8+i 
FUCOMP ST(i) 
Valid Valid 
Compare ST(0) with ST(i) and pop register stack.

DD E9 
FUCOMP 
Valid Valid 
Compare ST(0) with ST(1) and pop register stack.
DA E9 
FUCOMPP 
Valid Valid 
Compare ST(0) with ST(1) and pop register stack twice.

Description
Performs an unordered comparison of the contents of register ST(0) and ST(i) and sets condition code flags C0, C2,
and C3 in the FPU status word according to the results (see the table below). If no operand is specified, the
contents of registers ST(0) and ST(1) are compared. The sign of zero is ignored, so that –0.0 is equal to +0.0.
Table 3-51. FUCOM/FUCOMP/FUCOMPP Results
Comparison Results* C3 C2 C0
ST0 > ST(i) 0 0 0
ST0 < ST(i) 0 0 1
ST0 = ST(i) 1 0 0
Unordered 1 1 1
NOTES:
* Flags not set if unmasked invalid-arithmetic-operand (#IA) exception is generated.
An unordered comparison checks the class of the numbers being compared (see “FXAM—Examine ModR/M” in this
chapter). The FUCOM/FUCOMP/FUCOMPP instructions perform the same operations as the FCOM/FCOMP/FCOMPP
instructions. The only difference is that the FUCOM/FUCOMP/FUCOMPP instructions raise the invalid-arithmetic-
operand exception (#IA) only when either or both operands are an SNaN or are in an unsupported format; QNaNs
cause the condition code flags to be set to unordered, but do not cause an exception to be generated. The
FCOM/FCOMP/FCOMPP instructions raise an invalid-operation exception when either or both of the operands are a
NaN value of any kind or are in an unsupported format.
As with the FCOM/FCOMP/FCOMPP instructions, if the operation results in an invalid-arithmetic-operand exception
being raised, the condition code flags are set only if the exception is masked.
The FUCOMP instruction pops the register stack following the comparison operation and the FUCOMPP instruction
pops the register stack twice following the comparison operation. To pop the register stack, the processor marks
the ST(0) register as empty and increments the stack pointer (TOP) by 1.
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

Operation
CASE (relation of operands) OF
ST > SRC:
C3, C2, C0 ← 000;
ST < SRC:
C3, C2, C0 ← 001;
ST = SRC:
C3, C2, C0 ← 100;
ESAC;
IF ST(0) or SRC = QNaN, but not SNaN or unsupported format
THEN
C3, C2, C0 ← 111;
ELSE (* ST(0) or SRC is SNaN or unsupported format *)
#IA;
IF FPUControlWord.IM = 1
THEN
C3, C2, C0 ← 111;
FI;
FI;
IF Instruction = FUCOMP
THEN
PopRegisterStack;
FI;
IF Instruction = FUCOMPP
THEN
PopRegisterStack;
FI;

FPU Flags Affected
C1 Set to 0 if stack underflow occurred.
C0, C2, C3 See Table 3-51.
---------------------------------------------------------------------

411
FXAM—Examine ModR/M

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

D9 E5 
FXAM 
Valid Valid 
Classify value or number in ST(0).

Description
Examines the contents of the ST(0) register and sets the condition code flags C0, C2, and C3 in the FPU status word
to indicate the class of value or number in the register (see the table below).
Table 3-52. FXAM Results
.
Class
C3 C2 C0
Unsupported 0 0 0
NaN 0 0 1
Normal finite number 0 1 0
Infinity 0 1 1
Zero 1 0 0
Empty 1 0 1
Denormal number 1 1 0
The C1 flag is set to the sign of the value in ST(0), regardless of whether the register is empty or full.
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

Operation
C1 ← sign bit of ST; (* 0 for positive, 1 for negative *)
CASE (class of value or number in ST(0)) OF
Unsupported:C3, C2, C0 ← 000;
NaN:
C3, C2, C0 ← 001;
Normal:
C3, C2, C0 ← 010;
Infinity:
C3, C2, C0 ← 011;
Zero:
C3, C2, C0 ← 100;
Empty:
C3, C2, C0 ← 101;
Denormal:
C3, C2, C0 ← 110;
ESAC;

FPU Flags Affected
C1 Sign of value in ST(0).
C0, C2, C3 See Table 3-52.
---------------------------------------------------------------------

413
FXCH—Exchange Register Contents

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

D9 C8+i 
FXCH ST(i) 
Valid Valid 
Exchange the contents of ST(0) and ST(i).

D9 C9 
FXCH 
Valid Valid 
Exchange the contents of ST(0) and ST(1).

Description
Exchanges the contents of registers ST(0) and ST(i). If no source operand is specified, the contents of ST(0) and
ST(1) are exchanged.
This instruction provides a simple means of moving values in the FPU register stack to the top of the stack [ST(0)],
so that they can be operated on by those floating-point instructions that can only operate on values in ST(0). For
example, the following instruction sequence takes the square root of the third register from the top of the register
stack:
FXCH ST(3);
FSQRT;
FXCH ST(3);
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

Operation
IF (Number-of-operands) is 1
THEN
temp ← ST(0);
ST(0) ← SRC;
SRC ← temp;
ELSE
temp ← ST(0);
ST(0) ← ST(1);
ST(1) ← temp;
FI;

FPU Flags Affected
C1 Set to 0 if stack underflow occurred; otherwise, set to 1.
C0, C2, C3 Undefined.
---------------------------------------------------------------------

415
FXRSTOR—Restore x87 FPU, MMX , XMM, and MXCSR State

Opcode/ Op/ 64-Bit Compat/ Description
Instruction En Mode Leg Mode

0F AE /1 
FXRSTOR m512byte
M Valid Valid 
Restore the x87 FPU, MMX, XMM, and MXCSR
 register state from m512byte.

REX.W+ 0F AE /1
FXRSTOR64 m512byte
M Valid N.E. 
Restore the x87 FPU, MMX, XMM, and MXCSR
 register state from m512byte.

Instruction Operand Encoding
Op/En Operand 1 Operand 2 Operand 3 Operand 4
M ModRM:r/m (r) NA NA NA

Description
Reloads the x87 FPU, MMX technology, XMM, and MXCSR registers from the 512-byte memory image specified in
the source operand. This data should have been written to memory previously using the FXSAVE instruction, and
in the same format as required by the operating modes. The first byte of the data should be located on a 16-byte
boundary. There are three distinct layouts of the FXSAVE state map: one for legacy and compatibility mode, a
second format for 64-bit mode FXSAVE/FXRSTOR with REX.W=0, and the third format is for 64-bit mode with
FXSAVE64/FXRSTOR64. Table 3-53 shows the layout of the legacy/compatibility mode state information in
memory and describes the fields in the memory image for the FXRSTOR and FXSAVE instructions. Table 3-56
shows the layout of the 64-bit mode state information when REX.W is set (FXSAVE64/FXRSTOR64). Table 3-57
shows the layout of the 64-bit mode state information when REX.W is clear (FXSAVE/FXRSTOR).
The state image referenced with an FXRSTOR instruction must have been saved using an FXSAVE instruction or be
in the same format as required by Table 3-53, Table 3-56, or Table 3-57. Referencing a state image saved with an
FSAVE, FNSAVE instruction or incompatible field layout will result in an incorrect state restoration.
The FXRSTOR instruction does not flush pending x87 FPU exceptions. To check and raise exceptions when loading
x87 FPU state information with the FXRSTOR instruction, use an FWAIT instruction after the FXRSTOR instruction.
If the OSFXSR bit in control register CR4 is not set, the FXRSTOR instruction may not restore the states of the XMM
and MXCSR registers. This behavior is implementation dependent.
If the MXCSR state contains an unmasked exception with a corresponding status flag also set, loading the register
with the FXRSTOR instruction will not result in a SIMD floating-point error condition being generated. Only the next
occurrence of this unmasked exception will result in the exception being generated.
Bits 16 through 32 of the MXCSR register are defined as reserved and should be set to 0. Attempting to write a 1
in any of these bits from the saved state image will result in a general protection exception (#GP) being generated.
Bytes 464:511 of an FXSAVE image are available for software use. FXRSTOR ignores the content of bytes 464:511
in an FXSAVE state image.

Operation
(x87 FPU, MMX, XMM7-XMM0, MXCSR) ← Load(SRC);
---------------------------------------------------------------------

418
FXSAVE—Save x87 FPU, MMX Technology, and SSE State

Opcode/ Op/ 64-Bit Compat/ Description
Instruction En Mode Leg Mode

0F AE /0 
FXSAVE m512byte
M Valid Valid 
Save the x87 FPU, MMX, XMM, and MXCSR
 register state to m512byte.

REX.W+ 0F AE /0
FXSAVE64 m512byte
M Valid N.E. 
Save the x87 FPU, MMX, XMM, and MXCSR
 register state to m512byte.

Instruction Operand Encoding
Op/En Operand 1 Operand 2 Operand 3 Operand 4
M ModRM:r/m (w) NA NA NA

Description
Saves the current state of the x87 FPU, MMX technology, XMM, and MXCSR registers to a 512-byte memory loca-
tion specified in the destination operand. The content layout of the 512 byte region depends on whether the
processor is operating in non-64-bit operating modes or 64-bit sub-mode of IA-32e mode.
Bytes 464:511 are available to software use. The processor does not write to bytes 464:511 of an FXSAVE area.
The operation of FXSAVE in non-64-bit modes is described first.

Non-64-Bit Mode Operation
Table 3-53 shows the layout of the state information in memory when the processor is operating in legacy modes.
Table 3-53. Non-64-bit-Mode Layout of FXSAVE and FXRSTOR
Memory Region
15
14
Rsvd
13
12
FPU CS
MXCSR_MASK
11 10
9
8
7
6
FPU IP FOP
MXCSR Rsrvd
5
4
Rsvd FTW
FPU DS
3
2
FSW
1
0
FCW
FPU DP
0
16
Reserved ST0/MM0 32
Reserved ST1/MM1 48
Reserved ST2/MM2 64
Reserved ST3/MM3 80
Reserved ST4/MM4 96
Reserved ST5/MM5 112
Reserved ST6/MM6 128
Reserved ST7/MM7 144
XMM0 XMM1 176
XMM2 192
XMM3 208
XMM4 224
XMM5 240
XMM6 256
XMM7 
160
272
Table 3-53. Non-64-bit-Mode Layout of FXSAVE and FXRSTOR
Memory Region (Contd.)
15
14
13
12
11 10
9
8
7
6
5
4
3
2
1
0
Reserved 288
Reserved 304
Reserved 320
Reserved 336
Reserved 352
Reserved 368
Reserved 384
Reserved 400
Reserved 416
Reserved 432
Reserved 448
Available 464
Available 480
Available 496
The destination operand contains the first byte of the memory image, and it must be aligned on a 16-byte
boundary. A misaligned destination operand will result in a general-protection (#GP) exception being generated (or
in some cases, an alignment check exception [#AC]).
The FXSAVE instruction is used when an operating system needs to perform a context switch or when an exception
handler needs to save and examine the current state of the x87 FPU, MMX technology, and/or XMM and MXCSR
registers.
The fields in Table 3-53 are defined in Table 3-54.
Table 3-54. Field Definitions
Field Definition
FCW x87 FPU Control Word (16 bits). See Figure 8-6 in the Intel® 64 and IA-32 Architectures Software
    Developer’s Manual, Volume 1, for the layout of the x87 FPU control word.
FSW x87 FPU Status Word (16 bits). See Figure 8-4 in the Intel® 64 and IA-32 Architectures Software
    Developer’s Manual, Volume 1, for the layout of the x87 FPU status word.
Abridged FTW x87 FPU Tag Word (8 bits). The tag information saved here is abridged, as described in the following
            paragraphs.
FOP x87 FPU Opcode (16 bits). The lower 11 bits of this field contain the opcode, upper 5 bits are reserved.
   See Figure 8-8 in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, for
     the layout of the x87 FPU opcode field.
FPU IP x87 FPU Instruction Pointer Offset (32 bits). The contents of this field differ depending on the current
      addressing mode (32-bit or 16-bit) of the processor when the FXSAVE instruction was executed:
32-bit mode — 32-bit IP offset.
16-bit mode — low 16 bits are IP offset; high 16 bits are reserved.
See “x87 FPU Instruction and Operand (Data) Pointers” in Chapter 8 of the Intel® 64 and IA-32
Architectures Software Developer’s Manual, Volume 1, for a description of the x87 FPU instruction
pointer.
FPU CS
x87 FPU Instruction Pointer Selector (16 bits). If CPUID.(EAX=07H,ECX=0H):EBX[bit 13] = 1, the
processor deprecates the FPU CS and FPU DS values, and this field is saved as 0000H.
Table 3-54. Field Definitions (Contd.)
Field Definition
FPU DP x87 FPU Instruction Operand (Data) Pointer Offset (32 bits). The contents of this field differ
      depending on the current addressing mode (32-bit or 16-bit) of the processor when the FXSAVE
     instruction was executed:
32-bit mode — 32-bit DP offset.
16-bit mode — low 16 bits are DP offset; high 16 bits are reserved.
See “x87 FPU Instruction and Operand (Data) Pointers” in Chapter 8 of the Intel® 64 and IA-32
Architectures Software Developer’s Manual, Volume 1, for a description of the x87 FPU operand
pointer.
FPU DS x87 FPU Instruction Operand (Data) Pointer Selector (16 bits). If CPUID.(EAX=07H,ECX=0H):EBX[bit
      13] = 1, the processor deprecates the FPU CS and FPU DS values, and this field is saved as 0000H.
MXCSR MXCSR Register State (32 bits). See Figure 10-3 in the Intel® 64 and IA-32 Architectures Software
      Developer’s Manual, Volume 1, for the layout of the MXCSR register. If the OSFXSR bit in control
       register CR4 is not set, the FXSAVE instruction may not save this register. This behavior is
      implementation dependent.
MXCSR_ MXCSR_MASK (32 bits). This mask can be used to adjust values written to the MXCSR register,
MASK ensuring that reserved bits are set to 0. Set the mask bits and flags in MXCSR to the mode of
    operation desired for SSE and SSE2 SIMD floating-point instructions. See “Guidelines for Writing to the
     MXCSR Register” in Chapter 11 of the Intel® 64 and IA-32 Architectures Software Developer’s Manual,
         Volume 1, for instructions for how to determine and use the MXCSR_MASK value.
ST0/MM0 through x87 FPU or MMX technology registers. These 80-bit fields contain the x87 FPU data registers or the
ST7/MM7 MMX technology registers, depending on the state of the processor prior to the execution of the
       FXSAVE instruction. If the processor had been executing x87 FPU instruction prior to the FXSAVE
      instruction, the x87 FPU data registers are saved; if it had been executing MMX instructions (or SSE or
     SSE2 instructions that operated on the MMX technology registers), the MMX technology registers are
    saved. When the MMX technology registers are saved, the high 16 bits of the field are reserved.
XMM0 through XMM7 XMM registers (128 bits per field). If the OSFXSR bit in control register CR4 is not set, the FXSAVE
                 instruction may not save these registers. This behavior is implementation dependent.
The FXSAVE instruction saves an abridged version of the x87 FPU tag word in the FTW field (unlike the FSAVE
instruction, which saves the complete tag word). The tag information is saved in physical register order (R0
through R7), rather than in top-of-stack (TOS) order. With the FXSAVE instruction, however, only a single bit (1 for
valid or 0 for empty) is saved for each tag. For example, assume that the tag word is currently set as follows:
R7 R6 R5 R4 R3 R2 R1 R0
11 xx xx xx 11 11 11 11
Here, 11B indicates empty stack elements and “xx” indicates valid (00B), zero (01B), or special (10B).
For this example, the FXSAVE instruction saves only the following 8 bits of information:
R7 R6 R5 R4 R3 R2 R1 R0
0 1 1 1 0 0 0 0
Here, a 1 is saved for any valid, zero, or special tag, and a 0 is saved for any empty tag.
The operation of the FXSAVE instruction differs from that of the FSAVE instruction, the as follows:
• FXSAVE instruction does not check for pending unmasked floating-point exceptions. (The FXSAVE operation in
   this regard is similar to the operation of the FNSAVE instruction).
• After the FXSAVE instruction has saved the state of the x87 FPU, MMX technology, XMM, and MXCSR registers,
   the processor retains the contents of the registers. Because of this behavior, the FXSAVE instruction cannot be
  used by an application program to pass a “clean” x87 FPU state to a procedure, since it retains the current
     state. To clean the x87 FPU state, an application must explicitly execute an FINIT instruction after an FXSAVE
    instruction to reinitialize the x87 FPU state.
• The format of the memory image saved with the FXSAVE instruction is the same regardless of the current
   addressing mode (32-bit or 16-bit) and operating mode (protected, real address, or system management).
This behavior differs from the FSAVE instructions, where the memory image format is different depending on
the addressing mode and operating mode. Because of the different image formats, the memory image saved
with the FXSAVE instruction cannot be restored correctly with the FRSTOR instruction, and likewise the state
saved with the FSAVE instruction cannot be restored correctly with the FXRSTOR instruction.
The FSAVE format for FTW can be recreated from the FTW valid bits and the stored 80-bit FP data (assuming the
stored data was not the contents of MMX technology registers) using Table 3-55.
Table 3-55. Recreating FSAVE Format
Exponent Exponent Fraction J and M FTW valid bit 0 0 0 0x 1 Special 10
all 1’s all 0’s all 0’s bits 
0 0 0 1x 1 Valid 00
0 0 1 00 1 Special 10
0 0 1 10 1 Valid 00
0 1 0 0x 1 Special 10
0 1 0 1x 1 Special 10
0 1 1 00 1 Zero 01
0 1 1 10 1 Special 10
1 0 0 1x 1 Special 10
1 0 0 1x 1 Special 10
1 0 1 00 1 Special 10
1 0 1 10 1 Special 10
0 Empty 11
For all legal combinations above.
x87 FTW
The J-bit is defined to be the 1-bit binary integer to the left of the decimal place in the significand. The M-bit is
defined to be the most significant bit of the fractional portion of the significand (i.e., the bit immediately to the right
of the decimal place).
When the M-bit is the most significant bit of the fractional portion of the significand, it must be 0 if the fraction is
all 0’s.

IA-32e Mode Operation
In compatibility sub-mode of IA-32e mode, legacy SSE registers, XMM0 through XMM7, are saved according to the
legacy FXSAVE map. In 64-bit mode, all of the SSE registers, XMM0 through XMM15, are saved. Additionally, there
are two different layouts of the FXSAVE map in 64-bit mode, corresponding to FXSAVE64 (which requires
REX.W=1) and FXSAVE (REX.W=0). In the FXSAVE64 map (Table 3-56), the FPU IP and FPU DP pointers are 64-bit
wide. In the FXSAVE map for 64-bit mode (Table 3-57), the FPU IP and FPU DP pointers are 32-bits.
Table 3-56. Layout of the 64-bit-mode FXSAVE64 Map
(requires REX.W = 1)
15
14
13
12
11
10
9
FPU IP
MXCSR_MASK
8
7
6
FOP
MXCSR
5 4
Reserved FTW
FPU DP
3
2
FSW
1
0
FCW
0
16
Reserved ST0/MM0 32
Reserved ST1/MM1 48
Reserved ST2/MM2 64
Reserved ST3/MM3 80
Reserved ST4/MM4 96
Reserved ST5/MM5 112
Table 3-56. Layout of the 64-bit-mode FXSAVE64 Map
(requires REX.W = 1) (Contd.)
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1
0
Reserved ST6/MM6 128
Reserved ST7/MM7 144
XMM0 160
XMM1 176
XMM2 192
XMM3 208
XMM4 224
XMM5 240
XMM6 256
XMM7 272
XMM8 288
XMM9 304
XMM10 320
XMM11 336
XMM12 352
XMM13 368
XMM14 384
XMM15 400
Reserved 416
Reserved 432
Reserved 448
Available 464
Available 480
Available 496
Table 3-57. Layout of the 64-bit-mode FXSAVE Map (REX.W = 0)
15
14
Reserved
13
12
FPU CS
MXCSR_MASK
11
10
9
8
7
6
FPU IP FOP
MXCSR Reserved
5 4
Reserved FTW
FPU DS
3
2
FSW
1
0
FCW
FPU DP
0
16
Reserved ST0/MM0 32
Reserved ST1/MM1 48
Reserved ST2/MM2 64
Reserved ST3/MM3 80
Reserved ST4/MM4 96
Reserved ST5/MM5 112
Reserved ST6/MM6 128
Reserved ST7/MM7 144
XMM0
160
Table 3-57. Layout of the 64-bit-mode FXSAVE Map (REX.W = 0) (Contd.) (Contd.)
15
14
13
12
11
10
9
8
7
6
5
4
3
2
1
0
XMM1 176
XMM2 192
XMM3 208
XMM4 224
XMM5 240
XMM6 256
XMM7 272
XMM8 288
XMM9 304
XMM10 320
XMM11 336
XMM12 352
XMM13 368
XMM14 384
XMM15 400
Reserved 416
Reserved 432
Reserved 448
Available 464
Available 480
Available 496

Operation
IF 64-Bit Mode
THEN
IF REX.W = 1
THEN
DEST ← Save64BitPromotedFxsave(x87 FPU, MMX, XMM7-XMM0,
MXCSR);
ELSE
DEST ← Save64BitDefaultFxsave(x87 FPU, MMX, XMM7-XMM0, MXCSR);
FI;
ELSE
DEST ← SaveLegacyFxsave(x87 FPU, MMX, XMM7-XMM0, MXCSR);
FI;
---------------------------------------------------------------------

426
FXTRACT—Extract Exponent and Significand

Opcode/ 64-Bit Compat/ Description
Instruction Mode Leg Mode 

D9 F4 
FXTRACT
Valid Valid 
Separate value in ST(0) into exponent and significand, store
 exponent in ST(0), and push the significand onto the register
 stack.

Description
Separates the source value in the ST(0) register into its exponent and significand, stores the exponent in ST(0),
and pushes the significand onto the register stack. Following this operation, the new top-of-stack register ST(0)
contains the value of the original significand expressed as a floating-point value. The sign and significand of this
value are the same as those found in the source operand, and the exponent is 3FFFH (biased value for a true expo-
nent of zero). The ST(1) register contains the value of the original operand’s true (unbiased) exponent expressed
as a floating-point value. (The operation performed by this instruction is a superset of the IEEE-recommended
logb(x) function.)
This instruction and the F2XM1 instruction are useful for performing power and range scaling operations. The
FXTRACT instruction is also useful for converting numbers in double extended-precision floating-point format to
decimal representations (e.g., for printing or displaying).
If the floating-point zero-divide exception (#Z) is masked and the source operand is zero, an exponent value of –
∞ is stored in register ST(1) and 0 with the sign of the source operand is stored in register ST(0).
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

Operation
TEMP ← Significand(ST(0));
ST(0) ← Exponent(ST(0));
TOP← TOP − 1;
ST(0) ← TEMP;

FPU Flags Affected
C1 Set to 0 if stack underflow occurred; set to 1 if stack overflow occurred.
C0, C2, C3 Undefined.
---------------------------------------------------------------------

428
FYL2X—Compute y ∗ log2x

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

D9 F1 
FYL2X 
Valid Valid 
Replace ST(1) with (ST(1) ∗ log2ST(0)) and pop the
 register stack.

Description
Computes (ST(1) ∗ log2 (ST(0))), stores the result in resister ST(1), and pops the FPU register stack. The source
operand in ST(0) must be a non-zero positive number.
The following table shows the results obtained when taking the log of various classes of numbers, assuming that
neither overflow nor underflow occurs.
Table 3-58. FYL2X Results
ST(0)
−∞ ±0 +0<+F<+1 +1 +F>+1 +∞ NaN
−∞ * * +∞ +∞ * −∞ −∞ NaN
−F * * ** +F −0 −F −∞ NaN
−0 * * * +0 −0 −0 * NaN
+0 * * * −0 +0 +0 * NaN
+F * * ** −F +0 +F +∞ NaN
+∞ * * ∞ −∞ * +∞ +∞ NaN
NaN 
ST(1)
−F NaN NaN NaN NaN NaN NaN NaN NaN
−
NOTES:
F Means finite floating-point value.
* Indicates floating-point invalid-operation (#IA) exception.
** Indicates floating-point zero-divide (#Z) exception.
If the divide-by-zero exception is masked and register ST(0) contains ±0, the instruction returns ∞ with a sign that
is the opposite of the sign of the source operand in register ST(1).
The FYL2X instruction is designed with a built-in multiplication to optimize the calculation of logarithms with an
arbitrary positive base (b):
logbx ← (log2b)–1 ∗ log2x
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

Operation
ST(1) ← ST(1) ∗ log2ST(0);
PopRegisterStack;

FPU Flags Affected
C1
Set to 0 if stack underflow occurred.
Set if result was rounded up; cleared otherwise.
C0, C2, C3
Undefined.
---------------------------------------------------------------------

430
FYL2XP1—Compute y ∗ log2(x +1)

Opcode Instruction 64-Bit Compat/ Description
                   Mode Leg Mode 

D9 F9 
FYL2XP1 
Valid Valid 
Replace ST(1) with ST(1) ∗ log2(ST(0) + 1.0) and pop the
 register stack.

Description
Computes (ST(1) ∗ log2(ST(0) + 1.0)), stores the result in register ST(1), and pops the FPU register stack. The
source operand in ST(0) must be in the range:
– ( 1 – 2 ⁄ 2 ) )to ( 1 – 2 ⁄ 2 )
The source operand in ST(1) can range from −∞ to +∞. If the ST(0) operand is outside of its acceptable range, the
result is undefined and software should not rely on an exception being generated. Under some circumstances
exceptions may be generated when ST(0) is out of range, but this behavior is implementation specific and not
guaranteed.
The following table shows the results obtained when taking the log epsilon of various classes of numbers, assuming
that underflow does not occur.
Table 3-59. FYL2XP1 Results
ST(0)
−(1 − ( 2 ⁄ 2 )) to −0 +0 +0 to +(1 - ( 2 ⁄ 2 )) NaN
−∞ +∞ * * −∞ NaN
−F +F +0 -0 −F NaN
−0 +0 +0 -0 −0 NaN
+0 −0 −0 +0 +0 NaN
+F −F −0 +0 +F NaN
+∞ −∞ * * +∞ NaN
NaN 
ST(1)
-0 NaN NaN NaN NaN NaN
NOTES:
F Means finite floating-point value.
* Indicates floating-point invalid-operation (#IA) exception.
This instruction provides optimal accuracy for values of epsilon [the value in register ST(0)] that are close to 0. For
small epsilon (ε) values, more significant digits can be retained by using the FYL2XP1 instruction than by using
(ε+1) as an argument to the FYL2X instruction. The (ε+1) expression is commonly found in compound interest and
annuity calculations. The result can be simply converted into a value in another logarithm base by including a scale
factor in the ST(1) source operand. The following equation is used to calculate the scale factor for a particular loga-
rithm base, where n is the logarithm base desired for the result of the FYL2XP1 instruction:
scale factor ← logn 2
This instruction’s operation is the same in non-64-bit modes and 64-bit mode.

Operation
ST(1) ← ST(1) ∗ log2(ST(0) + 1.0);
PopRegisterStack;

FPU Flags Affected
C1
Set to 0 if stack underflow occurred.
Set if result was rounded up; cleared otherwise.
C0, C2, C3
Undefined.
---------------------------------------------------------------------
